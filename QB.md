### Question Bank (Data Structures and Algorithms)

1.  **What** are the three core constraints—unambiguous, finite, and effective—that an algorithm must satisfy, according to its definition?
2.  **Why** does the choice of data structure critically influence both software performance and code maintainability in software engineering?
3.  **How** does the concept of a "node" serve as a fundamental building block, illustrating its role in both linked lists and tree structures?
4.  **What** are the primary visual symbols used in flow charts, and what types of algorithm operations do the diamond and rectangle shapes specifically represent?
5.  **Why** is Worst Case Analysis considered the most critical analysis when evaluating an algorithm, even though Average Case Analysis provides the most realistic expectation of performance?
6.  **How** do Time Complexity and Space Complexity function as algorithm quality metrics, and how does the concept of scalability relate to these metrics?
7.  **What** does Big O notation O(log n) indicate about the performance scaling of a data structure, and which specific data structures mentioned in the sources achieve this complexity for their major operations?
8.  **How** does the contiguous memory allocation used by one-dimensional (1D) arrays enable O(1) random access, and what expense is typically associated with resizing this representation?
9.  **Why** are linked lists preferred over arrays in scenarios requiring frequent insertions and deletions, and what specific advantage do linked lists offer in terms of dynamic sizing?
10. **What** is the LIFO (Last-In-First-Out) principle of the Stack structure, and how is this principle utilized in managing function calls and implementing undo functionality?
11. **How** does the linked list implementation of a Queue achieve O(1) complexity for both enqueue and dequeue operations?
12. **What** are the major disadvantages of implementing a Queue using a fixed-size array compared to a linked list implementation?
13. **Why** does a Doubly Linked List require more memory usage per node than a Singly Linked List, and what benefit does this overhead provide?
14. **How** is the level or depth of a node calculated in a tree structure, and what is the difference between an ancestor node and a child node?
15. **What** is the defining structure and property of a Binary Search Tree (BST), and how does this property enable efficient search operations?
16. **How** does the performance of Search, Insertion, and Deletion operations change from the average case (O(log n)) to the worst case (O(n)) in a BST?
17. **What** is the sequence of visiting nodes (Root, Left subtree, Right subtree) for Preorder, Inorder, and Postorder traversal methods, and what specific purpose does Inorder traversal serve for a BST?
18. **How** does the Bubble Sort algorithm ensure that the largest element reaches the correct position during each pass, and what is the resulting total number of comparisons in the worst case for $n$ elements?
19. **Why** is Merge Sort often preferred over Bubble Sort or Insertion Sort for large datasets, and what fundamental algorithm design technique does Merge Sort utilize?
20. **What** makes sorting algorithms so fundamental in computer science that they are considered among the most studied problems, specifically regarding their role as a prerequisite for other efficient algorithms and in demonstrating complexity analysis?
